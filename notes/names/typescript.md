TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。
TypeScript 由微软开发的自由和开源的编程语言。
TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。

高级功能：
+ 类型注解 轻量级为函数或者变量添加约束的方式 通过 ```:[类型]```的方式 注明类型
编译时会提示类型不匹配，注意是提示不匹配，编译过程还是会执行并生成js文件，提供静态的代码分析，分析代码结构和提供类型注解
+ 接口 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。
```
interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = { firstName: "Jane", lastName: "User" };

document.body.innerHTML = greeter(user);
```
+ 类 
支持基于类的面向对象编程
在构造函数的参数上使用public等同于创建了同名的成员变量。


##  基础类型
| 数据类型| 关键字 |描述|
|  ----  | ----  | ---|
| 任意  | any |```let name:any="dsas"```<br>通常用于：变量的值会改变时、有选择性的包含或移除类型检测、定义存储各种类型数据的数组时|
| 数字  | number |```let i:number=1```|
|字符串|string|```let s:string="dad"```|
|布尔|boolean|```let f:boolean=fales```|
|数组|无 使用时在元素类型后加[]|```let arr:number[]=[1,2,3]```|
|元组|无 各元素的类型可以不同|let x:[number,string]=[1,"das"]|
|枚举|enum|```enum Color{red,green,blue};```<br>```let c: Color = Color.Blue;``` |
|空|void|表示方法没有返回值
|null|null|表示对象值缺失
|undefined|undefined|初始化变量为未定义
|never|never|代表从不会出现的值，是其他类型的子集（他可以转换成其他类型，但是其他类型不能转化成他） 在函数中通常表现为抛出异常或无法执行到终止点|

## 变量声明
### 四种声明方式：
```
var [变量名] : [类型] = 值;
var [变量名] : [类型];
var [变量名] = 值;
var [变量名];
```

### 类型断言：type assertion
用来手动指定一个值的类型，允许变量从一种类型更改为另外一种。
先做好一个假设，使得编译通过。类型断言更像是类型的选择，而不是类型转换
常见用途：
+ 将一个联合类型断言为其中一个类型
类型断言只能够「欺骗」TypeScript 编译器
当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法，而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，可以使用断言让编译器不报错。
+ 将一个父类断言为更加具体的子类
+ 将任何一个类型断言为 any
在 any 类型的变量上，访问任何属性都是允许的。
它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any
+ 将 any 断言为一个具体的类型
遇到 any 类型的变量时，我们可以选择无视它，任由它滋生更多的 any。
我们也可以选择改进它，通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。
+ 类型断言的限制
并不是任何一个类型都可以被断言成任何另一个类型
若A兼容B，那么A能被断言成B，B也能被断言成A
+ 双重断言
as any as 将任何一个类型断言为任何另外一个类型
除非万不得已，前往不要用

类型断言不是类型转换，它不会影响到变量的类型
#### 类型断言和类型声明的区别
类型声明是比类型断言更加严格的
如果使用类型声明，父类的实例不能赋值给子类的变量，但是断言可以
#### 类型断言和泛型 
使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件
```
function identity<T>(arg: T): T {
    return arg;
}}
```
相当于
```
function identity(arg: any): any {
    return arg;
}
```
使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。
T用于捕获输入类型， 之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。